- 포팅
    
    # DingDing 프로젝트 포팅 메뉴얼
    
    ## 목차
    
    1. 사용 도구
    2. 개발 도구
    3. 개발 환경
    4. 환경 변수
    5. CI/CD 구축 및 실행
    6. 외부 서비스 사용
    
    ---
    
    ## 1. 사용 도구
    
    - **형상 관리**
        - Gitlab
        - Git
    - **커뮤니케이션**
        - Notion
        - MatterMost
    - **와이어프레임**
        - Figma
    - **이슈 관리**
        - Jira
    - **CI/CD**
        - Docker
        - Dockerhub
        - Jenkins
        - Docker-compose
    
    ---
    
    ## 2. 개발 도구
    
    - **IntelliJ IDEA**: 2023.3.8
    - **Visual Studio Code**: 1.97.2
    
    ---
    
    ## 3. 개발 환경
    
    ### OS
    
    - **Ubuntu**: 22.04.5
    
    ### BackEnd
    
    - **Java OpenJDK**: **17.0.14**
    - **Spring Boot**: 3.4.3
    - **Spring Security**: 6.3.1.1
    - **Spring Data JPA**: 3.4.2
    - **Gradle**: 8.12.1
    - **JWT**: 0.11.5
    - **Python** 3.11.9
    - **FastAPI** 0.115.12
    - **uvicorn** 0.34.0
    - **websockets** 15.0.1
    
    ### FrontEnd
    
    - **TypeScript (ES6+)**
    - **Node.js**: 22.13.10
    - **React**: 19.0.0
    - **Vite**: 6.2.0
    - **Axios**: 1.8.2
    - **Tailwind CSS**: 3.4.17
    - **Framer Motion**: 12.6.2
    - **Zustand (State Management)**: 5.0.3
    - **Recoil (State Management)**: 0.7.7
    - **React Hook Form**: 7.54.2
    - **React Router DOM**: 7.3.0
    - **React Webcam**: 7.2.0
    - **React Icons**: 5.5.0
    - **Lucide React**: 0.483.0
    - **Charting Libraries**
        - **Recharts**: 2.15.1
        - **@nivo/line**: 0.88.0
    - **Three.js & 3D**
        - **Three**: 0.174.0
        - **@react-three/fiber**: 9.1.0
        - **@react-three/drei**: 10.0.5
        - **@types/three**: 0.174.0
    - **TensorFlow.js (AI 모델)**: 4.22.0
    - **Meyda (오디오 분석)**: 5.6.3
    - **Validation**
        - **Zod**: 3.24.2
    - **Date Utility**
        - **date-fns**: 4.1.0
    - **JWT 디코딩**: jwt-decode 4.0.0
    - **React Query**: @tanstack/react-query 5.70.0
    - **Headless UI**: @headlessui/react 2.2.0
    - **UUID 생성**: uuid 11.1.0
    
    ### Database
    
    - **MySQL :**  8.2.0
    - **AWS S3**
    - **IndexDB**
    
    ### Infra
    
    - **AWS EC2**
    - **Gitlab Webhook**
    - **Docker**: 26.1.3
    - **Docker-compose**: 2.24.1
    - **Jenkins**: 2.479.3
    - **Nginx**: 1.18.0
    - **Certbot**: 1.21.0
    
    ### 포트 정보
    
    - **BackEnd**: 8090
    - **FrontEnd**: 80
    - **Jenkins**: 8080
    - **FastAPI**: 8000
    - **MySQL**: 3306
    
    ---
    
    ## 4. 환경 변수
    
    ### application.yml
    
    ```yaml
    spring:
      profiles:
        active: dev
      datasource:
        driver-class-name: com.mysql.cj.jdbc.Driver
        url: jdbc:mysql://mysql:3306/ddingga?createDatabaseIfNotExist=true&useSSL=false&useUnicode=true&serverTimezone=Asia/Seoul&allowPublicKeyRetrieval=true
        username: ${MYSQL_USERNAME}
        password: ${MYSQL_PASSWORD}
        hikari:
          maximum-pool-size: 10
          minimum-idle: 5
          idle-timeout: 30000
          max-lifetime: 600000
          connection-timeout: 30000
          leak-detection-threshold: 30000 # 30초 이상 점유되면 로그로 찍힘
      application:
        name: ddingga
      jpa:
        properties:
          hibernate:
            format_sql: "true"
            dialect: org.hibernate.dialect.MySQLDialect
        show-sql: "true"
        hibernate:
          ddl-auto: update
      # 레디스 설정 jedis 방식은 동기처리 lettuce 방식은 비동기 처리
      data:
        redis:
          host: redis
          port: 6379
          password: ${REDIS_PASSWORD} #바꾸지마셈
          client-type: lettuce
          lettuce:
            pool:
              max-active: 10
              max-wait: 1000
              max-idle: 10
              min-idle: 1
      # 파일 업로드를 위한 설정
      servlet:
        multipart:
          max-file-size: 100MB
          max-request-size: 100MB
          enabled: true
      # AWS S3 설정
      cloud:
        aws:
          s3:
            bucket: ddingga
          region:
            static: ap-northeast-2
          credentials:
            access-key: ${AWS_S3_ACCESS_KEY}
            secret-key: ${AWS_S3_SECRET_KEY}
    
    jwt:
      # JWT 토큰 생성 및 검증에 사용되는 비밀키
      # 실제 운영 환경에서는 환경변수로 관리하는 것을 권장
      secret: ${JWT_SECRET}
      # Access Token 유효기간 (1시간)
      # 짧은 시간으로 설정하여 보안성 강화
      access-token-expiration: 86400
      # Refresh Token 유효기간 (7일)
      # Access Token보다 긴 시간으로 설정
      refresh-token-expiration: 604800
      # JWT 토큰 접두사
      # Authorization 헤더에서 토큰을 식별하는데 사용
      token-prefix: "Bearer "
      # HTTP 요청 헤더에서 JWT 토큰을 전달하는 헤더 이름
      header-string: "Authorization"
    
    server:
      port: 8090
    
    springdoc:
      swagger-ui:
        persist-authorization: true
    
    ```
    
    ### application-prod.yml
    
    (배포 전용 파일)
    
    ```yaml
    spring:
      profiles:
        active: dev
      datasource:
        driver-class-name: com.mysql.cj.jdbc.Driver
        url: jdbc:mysql://mysql:3306/ddingga?createDatabaseIfNotExist=true&useSSL=false&useUnicode=true&serverTimezone=Asia/Seoul&allowPublicKeyRetrieval=true
        username: ${MYSQL_USERNAME}
        password: ${MYSQL_PASSWORD}
        hikari:
          maximum-pool-size: 10
          minimum-idle: 5
          idle-timeout: 30000
          max-lifetime: 600000
          connection-timeout: 30000
          leak-detection-threshold: 30000 # 30초 이상 점유되면 로그로 찍힘
      application:
        name: ddingga
      jpa:
        properties:
          hibernate:
            format_sql: "true"
            dialect: org.hibernate.dialect.MySQLDialect
        show-sql: "true"
        hibernate:
          ddl-auto: update
      # 레디스 설정 jedis 방식은 동기처리 lettuce 방식은 비동기 처리
      data:
        redis:
          host: redis
          port: 6379
          password: ${REDIS_PASSWORD} #바꾸지마셈
          client-type: lettuce
          lettuce:
            pool:
              max-active: 10
              max-wait: 1000
              max-idle: 10
              min-idle: 1
      # 파일 업로드를 위한 설정
      servlet:
        multipart:
          max-file-size: 100MB
          max-request-size: 100MB
          enabled: true
      # AWS S3 설정
      cloud:
        aws:
          s3:
            bucket: ddingga
          region:
            static: ap-northeast-2
          credentials:
            access-key: ${AWS_S3_ACCESS_KEY}
            secret-key: ${AWS_S3_SECRET_KEY}
    
    jwt:
      # JWT 토큰 생성 및 검증에 사용되는 비밀키
      # 실제 운영 환경에서는 환경변수로 관리하는 것을 권장
      secret: ${JWT_SECRET}
      # Access Token 유효기간 (1시간)
      # 짧은 시간으로 설정하여 보안성 강화
      access-token-expiration: 86400
      # Refresh Token 유효기간 (7일)
      # Access Token보다 긴 시간으로 설정
      refresh-token-expiration: 604800
      # JWT 토큰 접두사
      # Authorization 헤더에서 토큰을 식별하는데 사용
      token-prefix: "Bearer "
      # HTTP 요청 헤더에서 JWT 토큰을 전달하는 헤더 이름
      header-string: "Authorization"
    
    server:
      port: 8090
    
    springdoc:
      swagger-ui:
        persist-authorization: true
    
    ```
    
    ### 5. CI/CD 구축 및 실행
    
    ---
    
    ### GitLab Webhooks 설정
    
    - 해당 레포지토리 접속 → 좌측하단 Settings → Webhooks → Add new webhook
        - URL
            - http://j12d105.p.ssafy.io:8181/jenkins/project/GitLab-Jenkins-CICD 넣기
        - Secret token
            - jenkins → gitlab 액세스 url  and  secret token(Generate) 해서 나온 코드 넣기
        - Push events
            - Wildcard pattern
                - frontend
        - Enable SSL verification 해제
        - Test → Push events
        - Status 200 뜬다면 OK
        - 실패시 URL,  Secret token 확인
    
    ### 기본 환경 설정
    
    1. **AWS EC2 접속**
        - pem 키가 있는 디렉토리에서 아래와 같이 접속
            
            ```bash
            
            # 예시
            ssh -i J12D105T.pem ubuntu@j12d105.p.ssafy.io
            
            ```
            
    2. **패키지업데이트 및 개발 도구 설치**
        
        ```bash
        
        sudo apt update
        sudo apt upgrade -y
        sudo apt install -y build-essential
        
        ```
        
    3. **ufw 포트 설정**
        - 현재 상태 확인: `sudo ufw status`
        - 포트 허용: `sudo ufw allow [포트 번호]`
            - **[포트 번호] 목록**
                - 22
                - 80
                - 44
                - 8989
                - 8181
                - 8000
                - 5173
                - 8090
                - 8091
                - 18000
                - 6379
                - 3306
                - 443
    
    ### Docker 설치
    
    1. **Set up Docker's `apt` repository.**
    
    ```json
    # Add Docker's official GPG key:
    sudo apt-get update
    sudo apt-get install ca-certificates curl
    sudo install -m 0755 -d /etc/apt/keyrings
    sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
    sudo chmod a+r /etc/apt/keyrings/docker.asc
    
    # Add the repository to Apt sources:
    echo \
      "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
      $(. /etc/os-release && echo "${UBUNTU_CODENAME:-$VERSION_CODENAME}") stable" | \
      sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
    sudo apt-get update
    ```
    
    1. **Install the Docker packages.**
    
    ```json
    sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
    ```
    
    1. **Docker pull jenkins** 
    
    ```json
    docker pull jenkins/jenkins:lts
    ```
    
    ### Docker & Docker-compose 설치
    
    1. **필수 패키지 설치**
        
        ```bash
        
        sudo apt-get install -y apt-transport-https ca-certificates curl gnupg-agent software-properties-common
        
        ```
        
    2. **Docker GPG 키 추가 및 레포지토리 추가**
        
        ```bash
        
        curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
        sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
        
        ```
        
    3. **Docker 및 Docker-compose 설치**
        
        ```bash
        
        sudo apt-get update
        sudo apt-get install -y docker-ce docker-ce-cli containerd.io
        sudo systemctl start docker
        sudo systemctl enable docker
        sudo usermod -aG docker $USER
        sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
        sudo chmod +x /usr/local/bin/docker-compose
        docker --version
        docker-compose --version
        
        ```
        
    4. **Docker 테스트**
        
        ```bash
        
        docker run hello-world
        ```
        
    5. **Docker Network 설치**
        
        ```json
        docker network backend_network
        ```
        
    
    ### docker-compose.yml 파일
    
    ```yaml
    version: '3.8'
    
    services:
      mysql:
        image: mysql:8.0
        container_name: mysql
        restart: always
        ports:
          - "3306:3306"
        environment:
          MYSQL_ROOT_PASSWORD: "${MYSQL_PASSWORD}"
          MYSQL_USERNAME: "${MYSQL_USERNAME}"
          MYSQL_PASSWORD: "${MYSQL_PASSWORD}"
        volumes:
          - mysql_data:/var/lib/mysql
        networks:
          - backend_network
        healthcheck:
          test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
          interval: 10s
          retries: 5
          start_period: 20s
        command:
          --slow_query_log=1
          --slow_query_log_file=/var/lib/mysql/mysql-slow.log
          --long_query_time=1
    
      redis:
        image: redis:latest
        container_name: redis
        restart: always
        command: redis-server --requirepass ${REDIS_PASSWORD}
        environment:
          - REDIS_PASSWORD=${REDIS_PASSWORD}
        ports:
          - "6379:6379"
        networks:
          - backend_network
        healthcheck:
          test: ["CMD", "redis-cli", "ping"]
          interval: 10s
          retries: 5
          start_period: 10s
    
      backend-1:
        image: jaeyeolyim/backend-server
        container_name: backend-1
        restart: on-failure
        ports:
          - "8090:8090"
        depends_on:
          mysql:
            condition: service_healthy
          redis:
            condition: service_healthy
        networks:
          - backend_network
        environment:
          - MYSQL_USERNAME=${MYSQL_USERNAME}
          - MYSQL_PASSWORD=${MYSQL_PASSWORD}
          - REDIS_HOST=redis
          - REDIS_PORT=6379
          - REDIS_PASSWORD=${REDIS_PASSWORD}
          - JWT_SECRET=${JWT_SECRET}
          - AWS_S3_ACCESS_KEY=${AWS_S3_ACCESS_KEY}
          - AWS_S3_SECRET_KEY=${AWS_S3_SECRET_KEY}
          - SPRING_PROFILES_ACTIVE=prod
    
      backend-2:
        image: jaeyeolyim/backend-server
        container_name: backend-2
        restart: always
        ports:
          - "8091:8090"
        depends_on:
          mysql:
            condition: service_healthy
          redis:
            condition: service_healthy
        networks:
          - backend_network
        environment:
          - MYSQL_USERNAME=${MYSQL_USERNAME}
          - MYSQL_PASSWORD=${MYSQL_PASSWORD}
          - REDIS_HOST=redis
          - REDIS_PORT=6379
          - REDIS_PASSWORD=${REDIS_PASSWORD}
          - JWT_SECRET=${JWT_SECRET}
          - AWS_S3_ACCESS_KEY=${AWS_S3_ACCESS_KEY}
          - AWS_S3_SECRET_KEY=${AWS_S3_SECRET_KEY}
          - SPRING_PROFILES_ACTIVE=prod
    
      nginx:
        image: jaeyeolyim/frontend-app:latest
        container_name: nginx
        restart: always
        ports:
          - "443:443"
          - "80:80"
          - "15080:15080"
        volumes:
          - /home/ubuntu/j12d105/nginx/nginx.conf:/etc/nginx/nginx.conf
          - /etc/letsencrypt:/etc/letsencrypt
          - /home/ubuntu/j12d105/nginx/frontend.env:/usr/share/nginx/.env
        extra_hosts:
          - "host.docker.internal:host-gateway"
        networks:
          - backend_network
    
    volumes:
      mysql_data:
    
    networks:
      backend_network:
        name: backend_network
        driver: bridge
    ```
    
    ### Dockerfile 예제
    
    ### BackEnd
    
    ```docker
    FROM openjdk:17-jdk-slim
    WORKDIR /app
    COPY backend/build/libs/*.jar app.jar
    COPY backend/src/main/resources/application.yml application.yml 
    ENTRYPOINT ["java", "-jar", "app.jar", "--spring.config.location=application.yml"]
    
    ```
    
    ### FrontEnd
    
    ```docker
    # Base Image
    FROM node:20-alpine AS build
    
    # Set working directory
    WORKDIR /app
    
    # 환경 변수 추가
    ARG VITE_BASE_URL
    ARG VITE_BACKEND_URL
    ENV VITE_BASE_URL=${VITE_BASE_URL}
    ENV VITE_BACKEND_URL=${VITE_BACKEND_URL}
    
    # Copy package.json and install dependencies
    COPY frontend/tsconfig.json ./tsconfig.json
    COPY frontend/ .  
    COPY frontend/package.json frontend/pnpm-lock.yaml ./
    
    RUN npm install -g pnpm && pnpm install
    
    # 환경 변수 확인 (디버깅용)
    RUN echo "VITE_BASE_URL is set to: $VITE_BASE_URL"
    RUN echo "VITE_BACKEND_URL is set to: $VITE_BACKEND_URL"
    
    # Build the project
    RUN pnpm run build
    
    # Use nginx to serve the build files
    FROM nginx:latest
    
    # Set working directory
    WORKDIR /usr/share/nginx/html
    
    # Remove default nginx content
    RUN rm -rf ./*
    
    # Copy build files from previous stage
    COPY --from=build /app/dist ./
    
    # Copy custom nginx config
    COPY nginx.conf /etc/nginx/nginx.conf
    
    # Expose port 80
    EXPOSE 80
    
    # Start Nginx
    CMD ["nginx", "-g", "daemon off;"]
    
    ```
    
    ### Jenkins 설정
    
    1. **Jenkins 컨테이너 실행**
        
        ```bash
        
        docker run -d \
          --name jenkins \
          --restart=on-failure \
          --network ci_network \
          -p 8181:8080 \
          -p 50000:50000 \
          -v /home/ubuntu/j12d105/jenkins:/var/jenkins_home \
          -v /var/run/docker.sock:/var/run/docker.sock \
          -e JENKINS_OPTS="--prefix=/jenkins" \
          -e TZ=Asia/Seoul \
          jenkins/jenkins:lts
        ```
        
        - 초기 관리자 비밀번호 확인
            
            ```bash
            
            docker exec jenkins-docker cat /var/jenkins_home/secrets/initialAdminPassword
            
            ```
            
    2. **Jenkins 권한 설정**
        - ubuntu 에서 아래 명령어 입력
        
        ```json
        sudo chown -R 1000:1000 /home/ubuntu/j12d105/jenkins
        sudo chmod -R 775 /home/ubuntu/j12d105/jenkins
        ```
        
    3. **Jenkins Docker-CLI 설치**
    
    ```json
    docker exec -it -u root jenkins bash
    
    apt update && apt install -y docker.io
    ```
    
    1. **Jenkins 초기 설정**
        - 웹 브라우저에서 http://j12d105.p.ssafy.io:8181/jenkins에 접속하여 초기 비밀번호 입력
        - Suggested Plugins 설치 후, 관리자 계정(ID: admin, password: wjdrlahdla 등) 생성
    2. **Jenkins 환경변수 설정**
        - GitLab → GitLab connections
            - Connection name 란에 GitLab-Jenkins-connection 입력
            - GitLab host URL 란에 https://lab.ssafy.com 입력
            - Credentials 란에 GitLab API token (GitLab-dlawoduf15-Accesstoken)입력
            - Test Connection 눌러보고 Success 가 뜨면 성공!
            - Save 버튼 클릭
            - Fail 일시 GitLab API token, GitLab host URL 확인
    3. **Credentials 등록 (Jenkins 관리 → Credentials)**
        - **GitLab Access Token**
            - GitLab에서 토큰 생성 후, Jenkins → Credentials → System → Global credentials 에 등록
                - Kind: GitLab API Token, ID: gitlab-token, Description: gitlab access
        - **Username with password**
            - GitLab에서 토큰 생성 후, Jenkins → Credentials → System → Global credentials 에 등록
        - **EC2 SSH Key 등록**
            - Kind: SSH Username with private key, ID: ubuntu-ssh-key, Username: ubuntu, Private Key: (J12D105T.pem)
        - **DockerHub Credentials 등록 매뉴얼**
            - Docker Hub : https://hub.docker.com 접속
            - 계정 정보 예시
                - **Username : jaeyeolyim**
                - **Password or Access Token :** 일반 비밀번호도 가능하지만, Access Token 권장
            - Access Token 발급 방법
                - Docker Hub 로그인 → 우측 상단 → `Account Settings`
                - `Security` → `New Access Token`
                - 토큰 이름 설정 후 발급 → 복사해서 저장
            - Jenkins에 등록하기
                - 위치 : Jenkins → Manage Jenkins → Credentials → (global) or 특정 domain → Add Credentials
                
                | 항목 | 값 |
                | --- | --- |
                | **Kind** | Username with password |
                | **Username** | Docker Hub ID (예: `jaeyeolyim`) |
                | **Password** | 비밀번호 또는 발급받은 **Access Token** |
                | **ID** | `docker-hub-credentials` ← 이 ID를 Jenkinsfile에서 사용 |
                | **Description** | Docker Hub Login for Jenkins push |
        - **MySQL Credentials 등록 매뉴얼**
            - MySQL 계정 준비
                - 일반적으로 Docker 컨테이너 또는 EC2 내 MySQL 인스턴스가 있고
                - 접속할 계정 정보가 있어야 함
            
            | 항목 | 예시 값 |
            | --- | --- |
            | **Username** | `root` 또는 `jenkins_user` |
            | **Password** | `your_secure_password` |
            | **Host** | `localhost`, `127.0.0.1`, `mysql`, 또는 원격 IP 주소 |
            | **Port** | `3306` (기본값) |
            - Jenkins에 등록 하기
                - 위치:
                    - Jenkins → `Manage Jenkins` → `Credentials`
                    - → `(global)` or 특정 domain → `Add Credentials`
                - 등록 1: MySQL Username
                    
                    
                    | 항목 | 값 |
                    | --- | --- |
                    | **Kind** | Secret text |
                    | **Secret** | 예: `jenkins_user` |
                    | **ID** | `MySQL-Username` |
                    | **Description** | MySQL 사용자 이름 (for Jenkins script) |
                - 등록 2: MySQL Password
                    
                    
                    | 항목 | 값 |
                    | --- | --- |
                    | **Kind** | Secret text |
                    | **Secret** | 예: `your_secure_password` |
                    | **ID** | `MySQL-Password` |
                    | **Description** | MySQL 사용자 비밀번호 (for Jenkins script) |
        - **MySQL-Root-Credentials**
            
            
            | 항목 | 값 |
            | --- | --- |
            | **Kind** | Secret text |
            | **Secret** | 예: `root:<비밀번호>` 또는 `비밀번호만` (사용 방식에 따라 다름) |
            | **ID** | `MySQL-Root-Credentials` |
            | **Description** | MySQL 루트 계정 비밀번호 |
        - **JWT_SECRET**
            
            
            | 항목 | 값 |
            | --- | --- |
            | **Kind** | Secret text |
            | **Secret** | 예: `my_super_secret_key_1234` |
            | **ID** | `JWT_SECRET` |
            | **Description** | JWT 암호화용 시크릿 키 |
        - **AWS_S3_ACCESS_KEY & AWS_S3_SECRET_KEY**
            
            
            | 항목 | AWS_S3_ACCESS_KEY | AWS_S3_SECRET_KEY |
            | --- | --- | --- |
            | **Kind** | Secret text | Secret text |
            | **Secret** | AWS 콘솔에서 발급받은 Access Key | AWS 콘솔에서 발급받은 Secret Key |
            | **ID** | `AWS_S3_ACCESS_KEY` | `AWS_S3_SECRET_KEY` |
            | **Description** | AWS S3 액세스 키 | AWS S3 시크릿 키 |
        - **VITE_BASE_URL**
            
            
            | 항목 | 값 |
            | --- | --- |
            | **Kind** | Secret text |
            | **Secret** | 예: `https://yourdomain.com` |
            | **ID** | `VITE_BASE_URL` |
            | **Description** | 프론트엔드의 BASE URL (도메인 주소)
            ex) https://j12d105.p.ssafy.io |
        - **VITE_BACKEND_URL**
            
            
            | 항목 | 값 |
            | --- | --- |
            | **Kind** | Secret text |
            | **Secret** | 예: `https://j12d105.p.ssafy.io/api` |
            | **ID** | `VITE_BACKEND_URL` |
            | **Description** | 백엔드 API 호출을 위한 엔드포인트 주소 |
    4. **Pipeline 생성 및 설정**
        - 신규 Item 생성 → Pipeline
        - **Github project**: 프로젝트 URL 설정 (예: https://lab.ssafy.com/xxx/yyy.git)
        - **Trigger 설정**: GitLab webhook을 통해 Push Events, Merge Request 등의 이벤트 발생 시 실행
            - Push Events, Opened Merge Request Events
            - Approved Merge Requests (EE-only) check
            - Comments check
        - **Pipeline script from SCM**:
            - SCM: Git
            - Repository URL: (프로젝트 URL)
            - Credentials: GitLab-dlawoduf15-Accesstoken
            - Branch Specifier: */frontend, */backend (각각의 빌드 분리)
            - Script Path: Jenkinsfile (Jenkinsfile 내 스크립트로 빌드, 배포 진행)
    
    ## Jenkinsfile 파일 예시
    
    ### Frontend
    
    ```json
    pipeline {
        agent any
    
        environment {
            IMAGE_NAME = "frontend-app"
            CONTAINER_NAME = "nginx"
            GIT_CREDENTIALS = credentials('dlawoduf15')  // GitLab Credentials
            DOCKER_HUB_CREDENTIALS = credentials('docker-hub-credentials')  // Docker Hub Credentials
            DOCKER_HUB_ID = "jaeyeolyim"  // Docker Hub 아이디
            MATTERMOST_WEBHOOK_URL = 'https://meeting.ssafy.com/hooks/9xbbpnkbqfyo3nzxjrkaib8xbc'  // Mattermost Incoming Webhook URL
            MATTERMOST_CHANNEL = 'd105-jenkins-alarm'  // Mattermost 채널
        }
    
        stages {
            stage('Checkout') {
                steps {
                    git branch: 'frontend', url: 'https://lab.ssafy.com/s12-ai-image-sub1/S12P21D105.git', credentialsId: 'dlawoduf15'
                    
                    script {  
                        echo "현재 체크아웃 브랜치 확인"
                        sh 'git branch'
                    }
                }
            }
    
            stage('Check Git') {
                steps {
                    sh 'git --version || echo "⚠️ Git을 찾을 수 없습니다."'
                }
            }
    
            stage('Build Docker Image') {
                steps {
                    script {
                        def startTime = System.currentTimeMillis()
    
                        withCredentials([string(credentialsId: 'GitLab-SecretText-Accesstoken', variable: 'GIT_TOKEN'), 
                        string(credentialsId: 'VITE_BACKEND_URL', variable: 'VITE_BACKEND_URL'),
                        string(credentialsId: 'VITE_BASE_URL', variable: 'VITE_BASE_URL')]) {
                            sh """
                            echo "🔐 GitLab Access Token을 .env 파일에 저장"
                            echo "GIT_CREDENTIALS=\$GIT_TOKEN" > .env
                            echo "VITE_BASE_URL=\$VITE_BASE_URL" >> .env
                            echo "VITE_BACKEND_URL=\$VITE_BACKEND_URL" >> .env
                            export VITE_BASE_URL=\$VITE_BASE_URL
                            export VITE_BACKEND_URL=\$VITE_BACKEND_URL
    
                            echo "🚀 Docker Image 빌드 시작"
                            docker build --build-arg VITE_BASE_URL=\$VITE_BASE_URL --build-arg VITE_BACKEND_URL=\$VITE_BACKEND_URL -t ${IMAGE_NAME} .
                            """
                        }
    
                        def endTime = System.currentTimeMillis()
                        def duration = (endTime - startTime) / 1000 
                        echo "🚀 프론트 빌드 완료: ${duration}초 소요"
                    }
                }
            }
    
            stage('Push to Docker Hub') {
                steps {
                    withCredentials([usernamePassword(credentialsId: 'docker-hub-credentials', usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
                        sh '''
                        echo "📦 Docker Hub 로그인 및 이미지 푸시"
                        echo "$DOCKER_PASS" | docker login -u "$DOCKER_USER" --password-stdin
    
                        docker tag frontend-app ${DOCKER_HUB_ID}/frontend-app:latest
                        docker push ${DOCKER_HUB_ID}/frontend-app:latest
    
                        docker logout
                        '''
                    }
                }
            }
    
            stage('Deploy (Nginx Only)') {
                steps {
                    sshagent(['ubuntu-ssh-key']) {
                        sh '''
                        ssh -o StrictHostKeyChecking=no ubuntu@j12d105.p.ssafy.io <<- EOF
                            cd /home/ubuntu/j12d105
    
                            echo "🛑 기존 nginx 컨테이너 중단 & 삭제"
                            docker-compose stop nginx || true
                            docker-compose rm -f nginx || true
    
                            echo "🚀 최신 프론트엔드 이미지 가져오기"
                            docker pull ${DOCKER_HUB_ID}/frontend-app:latest
    
                            echo "🚀 nginx 컨테이너 다시 실행"
                            docker-compose up -d --build nginx
    
                            echo "✅ nginx + 프론트엔드 배포 완료! 현재 컨테이너 상태:"
                            docker ps -a
    
                            exit 0
                        EOF
                        '''
                    }
                }
            }
        }
    
        post {
            success {
                echo '✅ Deployment Successful!'
    
                // GitLab 커밋 기록에서 배포한 사람의 GitLab 아이디 추출
                script {
                    def Author_ID = sh(script: "git show -s --pretty=%an", returnStdout: true).trim()
                    def Author_Name = sh(script: "git show -s --pretty=%ae", returnStdout: true).trim()
                    def Name = Author_ID.substring(1)
    
                    // Mattermost 알림 전송 (빌드 성공 시)
                    mattermostSend(
                        color: 'good',
                        message: "${env.JOB_NAME}의 Jenkins ${env.BUILD_NUMBER}번째 빌드가 성공했습니다! \n배포한 사람: ${Name} ㅋㅋ좀치노 \n브랜치: ${env.GIT_BRANCH} \n(<${env.BUILD_URL}|상세 보기>)",
                        endpoint: "${env.MATTERMOST_WEBHOOK_URL}",
                        channel: "${env.MATTERMOST_CHANNEL}"
                    )
                }
            }
            failure {
                echo '❌ Deployment Failed.'
                
                script {
                    // GitLab 커밋 기록에서 배포한 사람의 GitLab 아이디 추출
                    def Author_ID = sh(script: "git show -s --pretty=%an", returnStdout: true).trim()
                    def Author_Name = sh(script: "git show -s --pretty=%ae", returnStdout: true).trim()
                    def Name = Author_ID.substring(1)
    
                    // Mattermost 알림 전송 (빌드 실패 시)
                    mattermostSend(
                        color: 'danger',
                        message: "${env.JOB_NAME}의 Jenkins ${env.BUILD_NUMBER}번째 빌드가 실패했습니다. \n배포한 사람: ${Name} 뭐함? \n${env.GIT_BRANCH}에서 오류가 발생했습니다. \n(<${env.BUILD_URL}|상세 보기>)",
                        endpoint: "${env.MATTERMOST_WEBHOOK_URL}",
                        channel: "${env.MATTERMOST_CHANNEL}"
                    )
                }
            }
        }
    }
    
    ```
    
    ### Backend
    
    ```json
    // backend jenkinsfile
    pipeline {
        agent any
    
        environment {
            COMPOSE_FILE_PATH = "/home/ubuntu/j12d105/docker-compose.yml"
            IMAGE_NAME = "backend-server"
            DOCKER_HUB_ID = "jaeyeolyim"  // Docker Hub 아이디
            MATTERMOST_WEBHOOK_URL = 'https://meeting.ssafy.com/hooks/9xbbpnkbqfyo3nzxjrkaib8xbc'  // Mattermost Incoming Webhook URL
            MATTERMOST_CHANNEL = 'd105-jenkins-alarm'  // Mattermost 채널
        }
    
        stages {
            stage('Checkout') {
                steps {
                    git branch: 'backend', url: 'https://lab.ssafy.com/s12-ai-image-sub1/S12P21D105.git', credentialsId: 'dlawoduf15'
                }
            }
    
            stage('Build JAR') {
                steps {
                    script {
                        sh '''
                        chmod +x backend/gradlew
                        cd backend
                        ./gradlew clean build --exclude-task test
                        '''
                    }
                }
            }
            stage('Copy application.yml') {
                steps {
                    script {
                        sh '''
                        cp backend/src/main/resources/application.yml backend/build/libs/
                        '''
                    }
                }
            }
            stage('Build Docker Image') {
                steps {
                    script {
                        echo "🚀 Docker 이미지 빌드 시작!"
                        sh "docker build -t ${DOCKER_HUB_ID}/${IMAGE_NAME}:latest -f Dockerfile ."
                    }
                }
            }
    
            stage('Push to Docker Hub') {
                steps {
                    withCredentials([usernamePassword(credentialsId: 'docker-hub-credentials', usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
                        sh '''
                        echo "$DOCKER_PASS" | docker login -u "$DOCKER_USER" --password-stdin
                        docker push ${DOCKER_HUB_ID}/${IMAGE_NAME}:latest
                        docker logout
                        '''
                    }
                }
            }
    
            stage('Deploy (Backend-1, Backend-2, MySQL, Redis)') {
                steps {
                    sshagent(['ubuntu-ssh-key']) {
                        withCredentials([
                            string(credentialsId: 'MySQL-Username', variable: 'MYSQL_USERNAME'),
                            string(credentialsId: 'MySQL-Password', variable: 'MYSQL_PASSWORD'),
                            string(credentialsId: 'REDIS_PASSWORD', variable: 'REDIS_PASSWORD'),
                            string(credentialsId: 'JWT_SECRET', variable: 'JWT_SECRET'),
                            string(credentialsId: 'AWS_S3_ACCESS_KEY', variable: 'AWS_S3_ACCESS_KEY'),
                            string(credentialsId: 'AWS_S3_SECRET_KEY', variable: 'AWS_S3_SECRET_KEY'),
                        ]) {
                            script {
                                sh """
                                ssh -o StrictHostKeyChecking=no ubuntu@j12d105.p.ssafy.io <<- EOF
                                cd /home/ubuntu/j12d105
    
                                echo "🛑 기존 백엔드, MySQL, Redis 컨테이너 중단 & 삭제"
                                docker-compose down
    
                                echo "🚀 최신 백엔드 이미지 가져오기"
                                docker-compose pull backend-1 backend-2
    
                                echo "🚀 환경 변수 설정 후 컨테이너 실행"
                                export MYSQL_USERNAME="${MYSQL_USERNAME}"
                                export MYSQL_PASSWORD="${MYSQL_PASSWORD}"
                                export REDIS_PASSWORD="${REDIS_PASSWORD}"
                                export JWT_SECRET="${JWT_SECRET}"
                                export AWS_S3_ACCESS_KEY="${AWS_S3_ACCESS_KEY}" 
                                export AWS_S3_SECRET_KEY="${AWS_S3_SECRET_KEY}" 
    
                                echo "MYSQL_USERNAME=${MYSQL_USERNAME}" >> .env
                                echo "MYSQL_PASSWORD=${MYSQL_PASSWORD}" >> .env
                                echo "REDIS_PASSWORD=${REDIS_PASSWORD}" >> .env
                                echo "JWT_SECRET=${JWT_SECRET}" >> .env
                                echo "AWS_S3_ACCESS_KEY=${AWS_S3_ACCESS_KEY}" >> .env
                                echo "AWS_S3_SECRET_KEY=${AWS_S3_SECRET_KEY}" >> .env
                                
    
                                docker-compose down --remove-orphans
                                MYSQL_USERNAME=${MYSQL_USERNAME} \
                                MYSQL_PASSWORD=${MYSQL_PASSWORD} \
                                REDIS_PASSWORD=${REDIS_PASSWORD} \
                                JWT_SECRET=${JWT_SECRET} \
                                AWS_S3_ACCESS_KEY=${AWS_S3_ACCESS_KEY} \
                                AWS_S3_SECRET_KEY=${AWS_S3_SECRET_KEY} \
                                docker-compose up -d --force-recreate
    
                                echo "✅ 배포 완료! 현재 컨테이너 상태:"
                                docker ps -a
                                exit 0
                                EOF
                                """
                            }
                        }
                    }
                }
            }
        }
        post {
            success {
                echo "✅ Deployment Successful!"
                
                // GitLab 커밋 기록에서 배포한 사람의 GitLab 아이디 추출
                script {
                    def Author_ID = sh(script: "git show -s --pretty=%an", returnStdout: true).trim()
                    def Author_Name = sh(script: "git show -s --pretty=%ae", returnStdout: true).trim()
                    def Name = Author_ID.substring(1)
    
                    // Mattermost 알림 전송 (빌드 성공 시)
                    mattermostSend(
                        color: 'good',
                        message: "${env.JOB_NAME}의 Jenkins ${env.BUILD_NUMBER}번째 빌드가 성공했습니다! \n배포한 사람: ${Name} ㅋㅋ좀치노 \n브랜치: ${env.GIT_BRANCH} \n(<${env.BUILD_URL}|상세 보기>)",
                        endpoint: "${env.MATTERMOST_WEBHOOK_URL}",
                        channel: "${env.MATTERMOST_CHANNEL}"
                    )
                }
            }
            failure {
                echo "❌ Deployment Failed."
                
                script {
                    // GitLab 커밋 기록에서 배포한 사람의 GitLab 아이디 추출
                    def Author_ID = sh(script: "git show -s --pretty=%an", returnStdout: true).trim()
                    def Author_Name = sh(script: "git show -s --pretty=%ae", returnStdout: true).trim()
                    def Name = Author_ID.substring(1)
    
                    // Mattermost 알림 전송 (빌드 실패 시)
                    mattermostSend(
                        color: 'danger',
                        message: "${env.JOB_NAME}의 Jenkins ${env.BUILD_NUMBER}번째 빌드가 실패했습니다. \n배포한 사람: ${Name} 뭐함? \n${env.GIT_BRANCH}에서 오류가 발생했습니다. \n(<${env.BUILD_URL}|상세 보기>)",
                        endpoint: "${env.MATTERMOST_WEBHOOK_URL}",
                        channel: "${env.MATTERMOST_CHANNEL}"
                    )
                }
            }
        }
    }
    
    ```
    
    ### Nginx 및 SSL 인증 설정
    
    1. **Nginx 및 cerbot 설치 (SSL 적용할 때)**
        
        ```json
        sudo apt update
        sudo apt install -y nginx certbot python3-certbot-nginx
        sudo systemctl start nginx
        sudo systemctl enable nginx
        ```
        
    2. **SSL 인증서 발급**
        
        ```json
        sudo certbot --nginx -d your-domain.com -d www.your-domain.com
        sudo certbot --nginx -d j12d105.p.ssafy.io -d www.j12d105.p.ssafy.io
        ```
        
    3. **Nginx 설정 (예시: `/j12d105/nginx/nginx.conf`)**
    
    ```bash
    worker_processes auto;
    
    events {
        worker_connections 1024;
    }
    
    http {
        # 로그 포맷 커스터마이즈
        log_format custom '$remote_addr - $remote_user [$time_local] "$request" '
                           '$status $body_bytes_sent "$http_referer" '
                           '"$http_user_agent" "$http_x_forwarded_for" '
                           '"$request_time" "$upstream_response_time" "$pipe"';
         # 기본 액세스 로그 설정
        access_log /var/log/nginx/access.log custom;
    
        # 에러 로그를 debug 레벨로 설정
        error_log /var/log/nginx/error.log debug;
        # WebSocket 연결을 위해 업그레이드 헤더 설정
        map $http_upgrade $connection_upgrade {
            default upgrade;
            ''      close;
        }
    
        include /etc/nginx/mime.types;
    
        # ✅ 백엔드 로드 밸런싱 설정
        upstream backend_servers {
            least_conn;
            server backend-1:8090;
            server backend-2:8090;
        }
    
        # ✅ SSE(Server-Sent Events) 서버 (IP 해시 기반 라우팅)
        upstream sse_servers {
            ip_hash;
            server backend-1:8090;
            server backend-2:8090;
        }
    
        # ✅ HTTP → HTTPS 자동 리디렉션
        server {
            listen 15080;
            server_name j12d105.p.ssafy.io;
            return 301 https://$host$request_uri;
        }
        map $scheme $cookie_flag {
        https "secure; HttpOnly; SameSite=Strict";
        default "HttpOnly; SameSite=Lax";
    }
        # ✅ 프론트 + 백엔드 + FastAPI HTTPS 적용
        server {
            listen [::]:443 ssl ipv6only=on;
            listen 443 ssl;
            server_name j12d105.p.ssafy.io;
    
            client_max_body_size 1024M;
    
            ssl_certificate /etc/letsencrypt/live/j12d105.p.ssafy.io/fullchain.pem;
            ssl_certificate_key /etc/letsencrypt/live/j12d105.p.ssafy.io/privkey.pem;
            include /etc/letsencrypt/options-ssl-nginx.conf;
            ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;
    
            # ✅ 프론트엔드 정적 파일 제공
            location / {
                root /usr/share/nginx/html;
                index index.html;
                try_files $uri /index.html;
    
                add_header Cache-Control "no-cache, no-store, must-revalidate";
                add_header Pragma "no-cache";
                add_header Expires 0;
            }
    
            # ✅ 백엔드 API 프록시 설정 (로드 밸런싱)
            location /api/ {
                proxy_pass http://backend_servers;
                proxy_http_version 1.1;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
                proxy_cookie_domain localhost j12d105.p.ssafy.io;
    
                        # 도메인 설정
                proxy_cookie_domain localhost j12d105.p.ssafy.io;
    
                # 동적으로 쿠키 속성 설정
                proxy_cookie_path / "/; $cookie_flag";
    
            }
    
            # ✅ SSE 요청 프록시
            location /api/sse/ {
                rewrite ^/api/sse/(.*)$ /$1 break;
                proxy_pass http://sse_servers;
                proxy_http_version 1.1;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
                proxy_buffering off;
            }
    
            #
            location /audio {
                proxy_pass https://classic-badly-reindeer.ngrok-free.app;
                proxy_http_version 1.1;
                proxy_set_header Upgrade $http_upgrade;
                proxy_set_header Connection "Upgrade";
                proxy_set_header Host classic-badly-reindeer.ngrok-free.app;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
                proxy_cache_bypass $http_upgrade;
                proxy_redirect off;
                proxy_ssl_verify off;
                proxy_ssl_server_name on;
                proxy_ssl_name classic-badly-reindeer.ngrok-free.app;
    
            }
    
            location /ws {
                proxy_pass https://classic-badly-reindeer.ngrok-free.app/ws;
                proxy_http_version 1.1;
                proxy_set_header Upgrade $http_upgrade;
                proxy_set_header Connection "Upgrade";
                proxy_set_header Host classic-badly-reindeer.ngrok-free.app;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
                proxy_cache_bypass $http_upgrade;
                proxy_redirect off;
                proxy_ssl_verify off;
                proxy_ssl_server_name on;
                proxy_ssl_name classic-badly-reindeer.ngrok-free.app;
        }
    
            # Swagger UI 프록시 설정
            location /api/swagger-ui/ {
                    allow all;
                    proxy_pass http://backend_servers;
                    proxy_set_header Host $host;
                    proxy_set_header X-Real-IP $remote_addr;
                    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto $scheme;
    
                    # Swagger UI에서 요청하는 모든 자원에 대해서도 프록시
                    rewrite ^/api/swagger-ui/(.*)$ /$1 break;
            }
    
            error_page 404 =200 /index.html;
        }
    }
    
    ```
    
    1. **SSL 인증서 발급 (Certbot 사용)**
        
        ```bash
        
        sudo apt-get update
        sudo apt-get upgrade
        sudo apt-get install python3-certbot-nginx
        sudo certbot certonly --nginx -d i12d105.p.ssafy.io
        
        ```
        
    
    ---
    

### 배포 시 특이사항

- 영상 ai의 인식 속도를 위해 로컬 서버에서 배포하여 공개서버로 전환하여 배포하였음.
- uvicorn으로 배포 후 ngrok으로 공개서버로 전환
- 해당 서버 nginx.conf에서 작성

```bash
ngrok authtoken {인증키}
```